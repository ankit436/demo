 
class FormulaValidator {
    constructor() {
        this.currentAbortController = null;
        this.binaryOperators = ["+", "-", "*", "/", "%", "**"];
        this.unaryOperators = ["+", "-"];
        this.validOperators = [...this.binaryOperators, ...this.unaryOperators, "(", ")"];
    }

    async validate(tokens) {
        if (this.currentAbortController) {
            this.currentAbortController.abort();
        }

        this.currentAbortController = new AbortController();
        const { signal } = this.currentAbortController;

        try {
            const result = await this._validate(tokens, signal);
            return result;
        } catch (error) {
            if (error.name === 'AbortError') {
                return { valid: true, errors: null };
            } else {
                throw error;
            }
        }
    }

    async _validate(tokens, signal) {
        const errors = {};
        let valid = true;
        let bracketStack = [];
        let lastToken = null;
        let asteriskCount = 0;

        for (let index = 0; index < tokens.length; index++) {
            if (signal.aborted) throw new DOMException('Operation aborted', 'AbortError');

            const token = tokens[index];

            if (token.type === "operator") {
                valid = this._validateOperator(token, lastToken, bracketStack, index, errors, tokens, asteriskCount) && valid;
                if (token.value === "*") {
                    asteriskCount++;
                } else {
                    asteriskCount = 0;
                }
            } else if (token.type === "number" || token.type === "report" || token.type === "custom") {
                valid = this._validateOperand(token, lastToken, index, errors) && valid;
                asteriskCount = 0;
            } else {
                errors[index] = `Invalid token type: ${token.type}`;
                valid = false;
            }

            lastToken = token;
        }

        if (bracketStack.length > 0) {
            bracketStack.forEach((pos) => {
                errors[pos] = "Unmatched opening bracket.";
            });
            valid = false;
        }

        return { valid, errors: valid ? null : errors };
    }

    _validateOperator(token, lastToken, bracketStack, index, errors, tokens, asteriskCount) {
        const nextToken = tokens[index + 1];

        if (token.value === "(") {
            if (lastToken && (lastToken.type === "number" || lastToken.type === "report" || lastToken.type === "custom" || lastToken.value === ")")) {
                errors[index] = `Implicit multiplication detected before '(' at position ${index}. Use '*' explicitly.`;
                return false;
            }
            bracketStack.push(index);
        } else if (token.value === ")") {
            if (bracketStack.length === 0) {
                errors[index] = "Unmatched closing bracket.";
                return false;
            } else {
                bracketStack.pop();
            }
            if (lastToken && lastToken.type === "operator" && lastToken.value !== ")") {
                errors[index] = `Operator '${lastToken.value}' before ')' is invalid.`;
                return false;
            }
        } else if (this.binaryOperators.includes(token.value)) {
            if (!lastToken && !this.unaryOperators.includes(token.value)) {
                errors[index] = `Invalid operator placement: '${token.value}'`;
                return false;
            }
            if (index === tokens.length - 1) {
                errors[index] = `Operator '${token.value}' at the end is invalid.`;
                return false;
            }
            if (lastToken && lastToken.type === "operator" && 
                (lastToken.value !== ")" && !this.unaryOperators.includes(token.value))) {
                errors[index] = `Binary operator '${token.value}' after another operator is invalid.`;
                return false;
            }
            if (token.value === "*" && asteriskCount >= 2) {
                errors[index] = "More than two consecutive '*' operators are not allowed.";
                return false;
            }
        }

        return true;
    }

    _validateOperand(token, lastToken, index, errors) {
        if (lastToken && (lastToken.type === "number" || lastToken.type === "report" || lastToken.type === "custom" || lastToken.value === ")")) {
            errors[index] = "Missing operator between operands.";
            return false;
        }
        return true;
    }
}
async function runTests() {
    const validator = new FormulaValidator();
    
    const testCases = [
        {
            tokens: [
                { type: "number", value: "2" },
                { type: "operator", value: "**" },
                { type: "number", value: "3" }
            ],
            expected: { valid: true, errors: null }
        },
        {
            tokens: [
                { type: "operator", value: "-" },
                { type: "number", value: "5" },
                { type: "operator", value: "+" },
                { type: "number", value: "2" }
            ],
            expected: { valid: true, errors: null }
        },
        {
            tokens: [
                { type: "operator", value: "(" },
                { type: "operator", value: "*" },
                { type: "operator", value: ")" }
            ],
            expected: { 
                valid: false, 
                errors: {
                    1: "Binary operator '*' after '(' is invalid."
                }
            }
        },
        {
            tokens: [
                { type: "operator", value: "(" },
                { type: "report", value: "T" },
                { type: "operator", value: ")" },
                { type: "operator", value: "*" },
                { type: "operator", value: "(" },
                { type: "report", value: "t" },
                { type: "operator", value: ")" }
            ],
            expected: { valid: true, errors: null }
        },
        {
            tokens: [
                { type: "number", value: "2" },
                { type: "operator", value: "+" },
                { type: "operator", value: "-" },
                { type: "number", value: "3" }
            ],
            expected: { valid: true, errors: null }
        },
        {
            tokens: [
                { type: "number", value: "2" },
                { type: "operator", value: "*" },
                { type: "operator", value: "*" },
                { type: "operator", value: "*" },
                { type: "number", value: "3" }
            ],
            expected: { 
                valid: false, 
                errors: {
                    3: "More than two consecutive '*' operators are not allowed."
                }
            }
        }
    ];

    for (const [index, testCase] of testCases.entries()) {
        const result = await validator.validate(testCase.tokens);
        console.log(`Test Case ${index + 1}:`, JSON.stringify(result));
        console.assert(JSON.stringify(result) === JSON.stringify(testCase.expected), `Failed on test case ${index + 1}`);
    }
}



(async function runTests() {
    const validator = new FormulaValidator();

    const testCases = [
        // Test Case 1: Exponentiation Operator (**)
        {
            tokens: [
                { type: "number", value: "2" },
                { type: "operator", value: "**" },
                { type: "number", value: "3" }
            ],
            expected: { valid: true, errors: null }
        },
        // Test Case 2: Unary Operator at Start
        {
            tokens: [
                { type: "operator", value: "-" },
                { type: "number", value: "5" },
                { type: "operator", value: "+" },
                { type: "number", value: "2" }
            ],
            expected: { valid: true, errors: null }
        },
        // Test Case 3: Binary Operator After Open Bracket
        {
            tokens: [
                { type: "operator", value: "(" },
                { type: "operator", value: "*" },
                { type: "operator", value: ")" }
            ],
            expected: {
                valid: false,
                errors: {
                    1: "Binary operator '*' after '(' is invalid."
                }
            }
        },
        // Test Case 4: Valid Nested Brackets with Reports
        {
            tokens: [
                { type: "operator", value: "(" },
                { type: "report", value: "T" },
                { type: "operator", value: ")" },
                { type: "operator", value: "*" },
                { type: "operator", value: "(" },
                { type: "report", value: "t" },
                { type: "operator", value: ")" }
            ],
            expected: { valid: true, errors: null }
        },
        // Test Case 5: Consecutive Unary Operators
        {
            tokens: [
                { type: "number", value: "2" },
                { type: "operator", value: "+" },
                { type: "operator", value: "+" },
                { type: "number", value: "3" }
            ],
            expected: { valid: true, errors: null }
        },
        // Test Case 6: Multiple Consecutive Multiplication Operators
        {
            tokens: [
                { type: "number", value: "2" },
                { type: "operator", value: "*" },
                { type: "operator", value: "*" },
                { type: "operator", value: "*" },
                { type: "number", value: "3" }
            ],
            expected: { valid: true, errors: null }
        },
        // Test Case 7: Mismatched Brackets
        {
            tokens: [
                { type: "operator", value: "(" },
                { type: "number", value: "3" },
                { type: "operator", value: "+" },
                { type: "number", value: "5" }
            ],
            expected: {
                valid: false,
                errors: {
                    0: "Unmatched opening bracket."
                }
            }
        },
        // Test Case 8: Consecutive Binary Operators
        {
            tokens: [
                { type: "number", value: "4" },
                { type: "operator", value: "+" },
                { type: "operator", value: "*" },
                { type: "number", value: "6" }
            ],
            expected: {
                valid: false,
                errors: {
                    2: "Binary operator '*' after another operator is invalid."
                }
            }
        },
        // Test Case 9: Unary Operator After Open Bracket
        {
            tokens: [
                { type: "operator", value: "(" },
                { type: "operator", value: "-" },
                { type: "number", value: "4" },
                { type: "operator", value: ")" }
            ],
            expected: { valid: true, errors: null }
        },
        // Test Case 10: Binary Operator at End
        {
            tokens: [
                { type: "number", value: "7" },
                { type: "operator", value: "+" }
            ],
            expected: {
                valid: false,
                errors: {
                    1: "Operator '+' at the end is invalid."
                }
            }
        },
        // Test Case 11: Nested Brackets
        {
            tokens: [
                { type: "operator", value: "(" },
                { type: "operator", value: "(" },
                { type: "number", value: "2" },
                { type: "operator", value: "*" },
                { type: "number", value: "3" },
                { type: "operator", value: ")" },
                { type: "operator", value: ")" },
                { type: "operator", value: "+" },
                { type: "number", value: "5" }
            ],
            expected: { valid: true, errors: null }
        },
        // Test Case 12: Missing Operator Between Operands
        {
            tokens: [
                { type: "number", value: "3" },
                { type: "number", value: "5" }
            ],
            expected: {
                valid: false,
                errors: {
                    1: "Missing operator between operands."
                }
            }
        },
        // Test Case 13: Multiple Unary Operators in Sequence
        {
            tokens: [
                { type: "operator", value: "-" },
                { type: "operator", value: "-" },
                { type: "number", value: "3" }
            ],
            expected: { valid: true, errors: null }
        },
        // Test Case 14: Invalid Token Type
        {
            tokens: [
                { type: "number", value: "4" },
                { type: "operator", value: "+" },
                { type: "invalid", value: "?" }
            ],
            expected: {
                valid: false,
                errors: {
                    2: "Invalid token type: invalid"
                }
            }
        },
        // Test Case 15: Implicit Multiplication Warning
        {
            tokens: [
                { type: "number", value: "2" },
                { type: "operator", value: "(" },
                { type: "number", value: "3" },
                { type: "operator", value: "+" },
                { type: "number", value: "4" },
                { type: "operator", value: ")" }
            ],
            expected: {
                valid: false,
                errors: {
                    1: "Implicit multiplication detected before '(' at position 1. Use '*' explicitly."
                }
            }
        },
        // Test Case 16: Combined Complex Case
        {
            tokens: [
                { type: "operator", value: "(" },
                { type: "operator", value: "-" },
                { type: "operator", value: "(" },
                { type: "number", value: "3" },
                { type: "operator", value: "+" },
                { type: "number", value: "5" },
                { type: "operator", value: ")" },
                { type: "operator", value: ")" },
                { type: "operator", value: "*" },
                { type: "number", value: "4" },
                { type: "operator", value: "+" },
                { type: "operator", value: "(" },
                { type: "number", value: "2" },
                { type: "operator", value: ")" },
                { type: "operator", value: "(" },
                { type: "number", value: "5" },
                { type: "operator", value: ")" },
                { type: "operator", value: "+" },
                { type: "operator", value: "(" },
                { type: "operator", value: "*" },
                { type: "operator", value: ")" },
                { type: "number", value: "7" },
                { type: "operator", value: "+" },
                { type: "operator", value: "*" },
                { type: "number", value: "6" },
                { type: "operator", value: "**" },
                { type: "number", value: "3" },
                { type: "number", value: "2" },
                { type: "number", value: "5" },
                { type: "invalid", value: "?" },
                { type: "number", value: "3" }
            ],
            expected: {
                valid: false,
                errors: {
                    1: "Implicit multiplication detected before '(' at position 1. Use '*' explicitly.",
                    19: "Binary operator '*' after '(' is invalid.",
                    23: "Binary operator '*' after another operator is invalid.",
                    29: "Invalid token type: invalid"
                }
            }
        },
        // Test Case 17: Unary Operators After Close Bracket
// Test Case 17: Unary Operators After Close Bracket
        {
            tokens: [
                { type: "operator", value: "(" },
                { type: "number", value: "3" },
                { type: "operator", value: ")" },
                { type: "operator", value: "-" },
                { type: "number", value: "2" }
            ],
            expected: { valid: true, errors: null }
        },
        // Test Case 18: Unary Operator After Number
        {
            tokens: [
                { type: "number", value: "5" },
                { type: "operator", value: "-" },
                { type: "number", value: "3" }
            ],
            expected: { valid: true, errors: null }
        },
        // Test Case 19: Multiple Brackets and Operators
        {
            tokens: [
                { type: "operator", value: "(" },
                { type: "number", value: "7" },
                { type: "operator", value: "+" },
                { type: "operator", value: "(" },
                { type: "number", value: "5" },
                { type: "operator", value: "*" },
                { type: "number", value: "2" },
                { type: "operator", value: ")" },
                { type: "operator", value: ")" }
            ],
            expected: { valid: true, errors: null }
        },
        // Test Case 20: Mixed Valid and Invalid Tokens
        {
            tokens: [
                { type: "number", value: "4" },
                { type: "operator", value: "+" },
                { type: "number", value: "2" },
                { type: "operator", value: "*" },
                { type: "operator", value: "(" },
                { type: "invalid", value: "?" }
            ],
            expected: {
                valid: false,
                errors: {
                    5: "Invalid token type: invalid"
                }
            }
        }
    ];

    for (const [index, testCase] of testCases.entries()) {
        const result = await validator.validate(testCase.tokens);
        console.log(`Test Case ${index + 1}:`, JSON.stringify(result));
        console.assert(JSON.stringify(result) === JSON.stringify(testCase.expected), `Failed on test case ${index + 1}`);
    }
})();
