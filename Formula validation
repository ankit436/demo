function isFormulaValid(formula) {
    const operators = ['+', '-', '*', '/', '%', '**', '//']; // Python operators
    let previousType = null;
    let bracketStack = [];

    for (let i = 0; i < formula.length; i++) {
        const current = formula[i];

        if (current.type === 'operator') {
            if (previousType === 'open_bracket' || previousType === null) {
                // Allow unary operators (+, -) after open bracket or at the start
                if (current.value === '+' || current.value === '-') {
                    // Valid unary operator at start or after '('
                } else {
                    return { isValid: false, position: i, msg: `Operator '${current.value}' cannot be placed here at position ${i + 1}.` };
                }
            } else if (previousType === 'operator') {
                return { isValid: false, position: i, msg: `Two consecutive operators found at position ${i + 1}.` };
            }
            if (!operators.includes(current.value)) {
                return { isValid: false, position: i, msg: `Invalid operator '${current.value}' at position ${i + 1}.` };
            }
        } else if (current.type === 'custom' || current.type === 'report') {
            if (previousType === 'close_bracket' || previousType === 'value') {
                return { isValid: false, position: i, msg: `Unexpected value '${current.label}' at position ${i + 1}. Expected an operator before this value.` };
            }
        } else if (current.type === 'open_bracket') {
            bracketStack.push('(');
            if (previousType === 'close_bracket' || previousType === 'value') {
                return { isValid: false, position: i, msg: `Unexpected '(' at position ${i + 1}. Expected an operator before this bracket.` };
            }
        } else if (current.type === 'close_bracket') {
            if (bracketStack.length === 0) {
                return { isValid: false, position: i, msg: `Unmatched ')' at position ${i + 1}.` };
            }
            if (previousType === 'operator' || previousType === 'open_bracket') {
                return { isValid: false, position: i, msg: `Unexpected ')' at position ${i + 1}. Expected a value or '(' before this bracket.` };
            }
            bracketStack.pop();
        }

        previousType = current.type === 'operator' ? 'operator' : 
                        current.type === 'open_bracket' ? 'open_bracket' :
                        current.type === 'close_bracket' ? 'close_bracket' : 
                        'value';
    }

    if (previousType === 'operator' || previousType === 'open_bracket') {
        return { isValid: false, position: formula.length - 1, msg: "Formula ends with an operator or open bracket." };
    }

    if (bracketStack.length !== 0) {
        return { isValid: false, position: formula.length - 1, msg: "There are unmatched '(' brackets." };
    }

    return { isValid: true, position: -1, msg: "Formula is valid." };
}

// Run all test cases
function runAllTestCases() {
    const testCases = [
        {
            description: "Valid Formula with Basic Operations",
            formula: [
                { 'type': 'custom', 'value': 3, 'label': '3' },
                { 'type': 'operator', 'value': '+', 'label': '+' },
                { 'type': 'custom', 'value': 2, 'label': '2' },
                { 'type': 'operator', 'value': '-', 'label': '-' },
                { 'type': 'custom', 'value': 1, 'label': '1' }
            ],
            expected: { isValid: true, position: -1, msg: "Formula is valid." }
        },
        {
            description: "Valid Formula with Leading Negative Number",
            formula: [
                { 'type': 'operator', 'value': '-', 'label': '-' },
                { 'type': 'custom', 'value': 3, 'label': '3' },
                { 'type': 'operator', 'value': '+', 'label': '+' },
                { 'type': 'custom', 'value': 1, 'label': '1' }
            ],
            expected: { isValid: true, position: -1, msg: "Formula is valid." }
        },
        {
            description: "Valid Formula with Parentheses and Unary Operator",
            formula: [
                { 'type': 'custom', 'value': 3, 'label': '3' },
                { 'type': 'operator', 'value': '-', 'label': '-' },
                { 'type': 'open_bracket', 'value': '(', 'label': '(' },
                { 'type': 'operator', 'value': '+', 'label': '+' },
                { 'type': 'custom', 'value': 2, 'label': '2' },
                { 'type': 'close_bracket', 'value': ')', 'label': ')' }
            ],
            expected: { isValid: true, position: -1, msg: "Formula is valid." }
        },
        {
            description: "Invalid Formula with Consecutive Operators",
            formula: [
                { 'type': 'custom', 'value': 3, 'label': '3' },
                { 'type': 'operator', 'value': '+', 'label': '+' },
                { 'type': 'operator', 'value': '-', 'label': '-' },
                { 'type': 'custom', 'value': 1, 'label': '1' }
            ],
            expected: { isValid: false, position: 2, msg: "Two consecutive operators found at position 3." }
        },
        {
            description: "Invalid Formula with Missing Operator",
            formula: [
                { 'type': 'custom', 'value': 3, 'label': '3' },
                { 'type': 'custom', 'value': 2, 'label': '2' }
            ],
            expected: { isValid: false, position: 1, msg: "Unexpected value '2' at position 2. Expected an operator before this value." }
        },
        {
            description: "Invalid Formula with Unmatched Closing Bracket",
            formula: [
                { 'type': 'custom', 'value': 3, 'label': '3' },
                { 'type': 'operator', 'value': '+', 'label': '+' },
                { 'type': 'custom', 'value': 2, 'label': '2' },
                { 'type': 'close_bracket', 'value': ')', 'label': ')' }
            ],
            expected: { isValid: false, position: 3, msg: "Unmatched ')' at position 4." }
        },
        {
            description: "Invalid Formula Ending with Operator",
            formula: [
                { 'type': 'custom', 'value': 3, 'label': '3' },
                { 'type': 'operator', 'value': '+', 'label': '+' }
            ],
            expected: { isValid: false, position: 1, msg: "Formula ends with an operator or open bracket." }
        },
        {
            description: "Invalid Formula with Unmatched Opening Bracket",
            formula: [
                { 'type': 'open_bracket', 'value': '(', 'label': '(' },
                { 'type': 'custom', 'value': 3, 'label': '3' },
                { 'type': 'operator', 'value': '+', 'label': '+' },
                { 'type': 'custom', 'value': 1, 'label': '1' }
            ],
            expected: { isValid: false, position: 3, msg: "There are unmatched '(' brackets." }
        },
        {
            description: "Valid Formula with Complex Operations",
            formula: [
                { 'type': 'custom', 'value': 3, 'label': '3' },
                { 'type': 'operator', 'value': '**', 'label': '**' },
                { 'type': 'custom', 'value': 2, 'label': '2' },
                { 'type': 'operator', 'value': '//', 'label': '//' },
                { 'type': 'custom', 'value': 1, 'label': '1' }
            ],
            expected: { isValid: true, position: -1, msg: "Formula is valid." }
        },
        {
            description: "Invalid Formula with Unsupported Operator",
            formula: [
                { 'type': 'custom', 'value': 3, 'label': '3' },
                { 'type': 'operator', 'value': '&', 'label': '&' },
                { 'type': 'custom', 'value': 2, 'label': '2' }
            ],
            expected: { isValid: false, position: 1, msg: "Invalid operator '&' at position 2." }
        },
{
            description: "Valid Formula with Unary Plus Inside Parentheses",
            formula: [
                { 'type': 'custom', 'value': 3, 'label': '3' },
                { 'type': 'operator', 'value': '-', 'label': '-' },
                { 'type': 'open_bracket', 'value': '(', 'label': '(' },
                { 'type': 'operator', 'value': '+', 'label': '+' },
                { 'type': 'custom', 'value': 2, 'label': '2' },
                { 'type': 'close_bracket', 'value': ')', 'label': ')' }
            ],
            expected: { isValid: true, position: -1, msg: "Formula is valid." }
        }
    ];

    testCases.forEach((testCase, index) => {
        const result = isFormulaValid(testCase.formula);
        const passed = JSON.stringify(result) === JSON.stringify(testCase.expected);

        console.log(`Test Case ${index + 1}: ${testCase.description} - ${passed ? "Passed" : "Failed"}`);
        if (!passed) {
            console.log(`   Expected: ${JSON.stringify(testCase.expected)}`);
            console.log(`   Received: ${JSON.stringify(result)}`);
        }
    });
}

// Run all test cases
runAllTestCases();



 Certainly. I'll incorporate all the improvements and edge cases we discussed into the original logic. Here's the updated version of the `isFormulaValid` function that addresses all the cases:

```javascript
function isFormulaValid(formula) {
    const operators = new Set(['+', '-', '*', '/', '%', '**', '//']);
    let previousType = null;
    let bracketCount = 0;
    let errorDict = {};

    function addError(position, message) {
        if (!errorDict[position]) {
            errorDict[position] = [];
        }
        errorDict[position].push(message);
    }

    // Filter out spaces
    formula = formula.filter(item => item.type !== 'space');

    for (let i = 0; i < formula.length; i++) {
        const current = formula[i];
        const currentType = current.type;

        if (currentType === 'operator') {
            if (!operators.has(current.value)) {
                addError(i, `Invalid operator '${current.value}'.`);
            }
            if (previousType === 'open_bracket' || previousType === null || 
                (previousType === 'operator' && (current.value === '+' || current.value === '-'))) {
                // Allow multiple unary operators
                if (current.value !== '+' && current.value !== '-') {
                    addError(i, `Operator '${current.value}' cannot be placed here. Only '+' or '-' are allowed as unary operators.`);
                }
            } else if (previousType === 'operator' && current.value !== '+' && current.value !== '-') {
                addError(i - 1, `Consecutive operator '${formula[i-1].value}'.`);
                addError(i, `Consecutive operator '${current.value}'.`);
            }
        } else if (currentType === 'custom' || currentType === 'report' || currentType === 'value') {
            if (previousType === 'close_bracket' || previousType === 'value') {
                addError(i, `Unexpected value '${current.label || current.value}'. Add an operator before this value.`);
                addError(i - 1, `Missing operator before '${current.label || current.value}'.`);
            }
            if (currentType === 'value') {
                // Check for scientific notation and trailing decimal point
                const valueStr = current.value.toString();
                if (!/^-?(\d+\.?\d*|\.\d+)([eE][-+]?\d+)?$/.test(valueStr)) {
                    addError(i, `Invalid number format: '${valueStr}'.`);
                }
            }
        } else if (currentType === 'open_bracket') {
            bracketCount++;
            if (previousType === 'close_bracket' || previousType === 'value') {
                addError(i, `Unexpected '('. Add an operator before this bracket.`);
                addError(i - 1, `Missing operator before '('.`);
            }
        } else if (currentType === 'close_bracket') {
            if (bracketCount === 0) {
                addError(i, `Unmatched ')'. Add a matching '(' earlier in the formula.`);
            }
            if (previousType === 'operator' && i > 0 && formula[i-1].value !== '+' && formula[i-1].value !== '-') {
                addError(i, `Unexpected ')'. Add a value or '(' before this bracket.`);
                addError(i - 1, `Missing value or '(' before ')'.`);
            }
            bracketCount--;
        }

        previousType = currentType;
    }

    if (previousType === 'operator' && formula[formula.length - 1].value !== '+' && formula[formula.length - 1].value !== '-') {
        addError(formula.length - 1, "Formula ends with a non-unary operator. Complete the formula with a value or closing bracket.");
    }

    if (bracketCount !== 0) {
        let bracketError = bracketCount > 0 
            ? `There are ${bracketCount} unmatched '(' bracket(s). Add matching ')' to close all brackets.`
            : `There are ${Math.abs(bracketCount)} extra ')' bracket(s). Remove excess closing brackets or add matching '(' earlier in the formula.`;
        
        formula.forEach((item, index) => {
            if (item.type === 'open_bracket' || item.type === 'close_bracket') {
                addError(index, bracketError);
            }
        });
    }

    if (Object.keys(errorDict).length > 0) {
        let errorMessages = Object.entries(errorDict).map(([position, messages]) => 
            `Position ${parseInt(position) + 1}:\n${messages.map(msg => `  - ${msg}`).join('\n')}`
        ).join('\n\n');

        return {
            isValid: false,
            errorDict: errorDict,
            msg: `The formula contains the following errors:\n\n${errorMessages}`
        };
    }

    return { isValid: true, errorDict: {}, msg: "Formula is valid." };
}
```

This updated version addresses all the cases we discussed:

1. Spaces are filtered out at the beginning, so they're ignored in the validation process.
2. Multiple consecutive unary operators (+ and -) are allowed.
3. Empty parentheses are allowed (no error is raised for "()" ).
4. Scientific notation and numbers with trailing decimal points are properly handled with a regex check.
5. The function still checks for all the original cases like mismatched brackets, invalid operators, and improper placement of operators and values.

This version should now handle most Python-like formula evaluations correctly. However, it's important to note that this is still a simplified version and may not catch every possible edge case that Python handles. For the most accurate results, you'd need to implement a full parser and evaluator that mimics Python's exact behavior.

Is there any specific part of this updated function you'd like me to explain further?
