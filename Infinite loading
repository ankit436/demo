 I understand your concern. You're right that we need to prevent multiple calls to the same page. Let's modify the code to address this issue and ensure each page is only loaded once. Here's an updated version of the `CardList` component:

```jsx
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { Row, Col, Spin } from 'antd';
import CardItem from './CardItem';

const CARDS_PER_PAGE = 12;

const CardList = () => {
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(false);
  const [preloading, setPreloading] = useState(false);
  const [hasMore, setHasMore] = useState(true);
  const [page, setPage] = useState(1);
  const [loadedPages, setLoadedPages] = useState(new Set([1]));
  const observerRef = useRef(null);
  const lastCardRef = useRef(null);
  const loadingRef = useRef(false);

  const loadData = useCallback(
    async (pageToLoad, isPreload = false) => {
      if (loadedPages.has(pageToLoad) || loadingRef.current) return;

      loadingRef.current = true;
      if (isPreload) setPreloading(true);
      else setLoading(true);

      try {
        const newData = await fetchData(pageToLoad);
        if (newData.length === 0) {
          setHasMore(false);
        } else {
          setData((prevData) => [...prevData, ...newData]);
          setLoadedPages((prev) => new Set(prev).add(pageToLoad));
          setPage(pageToLoad);
        }
      } catch (error) {
        console.error('Error fetching data:', error);
      } finally {
        if (isPreload) setPreloading(false);
        else setLoading(false);
        loadingRef.current = false;
      }
    },
    [loadedPages]
  );

  useEffect(() => {
    const initialLoad = async () => {
      await loadData(1, false);
      if (hasMore) await loadData(2, true);
    };

    if (data.length === 0 && !loading && !preloading) {
      initialLoad();
    }
  }, [loadData, data.length, hasMore, loading, preloading]);

  useEffect(() => {
    if (!loading && hasMore) {
      const options = {
        root: null,
        rootMargin: '0px',
        threshold: 0.1,
      };

      observerRef.current = new IntersectionObserver((entries) => {
        const lastCard = entries[0];
        if (lastCard.isIntersecting && !loadingRef.current) {
          const nextPage = Math.floor(data.length / CARDS_PER_PAGE) + 1;
          if (!loadedPages.has(nextPage)) {
            loadData(nextPage, true);
          }
        }
      }, options);

      if (lastCardRef.current) {
        observerRef.current.observe(lastCardRef.current);
      }
    }

    return () => observerRef.current?.disconnect();
  }, [loading, hasMore, data, loadData, loadedPages]);

  return (
    <div style={{ padding: '20px' }}>
      <Row gutter={[16, 16]}>
        {data.map((item, index) => (
          <Col
            key={item.id}
            xs={24}
            sm={12}
            md={8}
            ref={index === data.length - CARDS_PER_PAGE / 2 ? lastCardRef : null}
          >
            <CardItem data={item} />
          </Col>
        ))}
      </Row>
      {loading && data.length === 0 && (
        <div style={{ textAlign: 'center', padding: '20px' }}>
          <Spin />
        </div>
      )}
      {!hasMore && !loading && (
        <div style={{ textAlign: 'center', padding: '20px', color: 'grey' }}>
          No more data to load
        </div>
      )}
      {preloading && (
        <div style={{ textAlign: 'center', padding: '20px', color: 'blue' }}>
          Loading more data...
        </div>
      )}
    </div>
  );
};

export default CardList;
```

Key changes to prevent multiple calls to the same page:

1. Added a `loadingRef` to track the loading state across renders:

```jsx
const loadingRef = useRef(false);
```

2. Modified the `loadData` function to use `loadingRef`:

```jsx
if (loadedPages.has(pageToLoad) || loadingRef.current) return;

loadingRef.current = true;
// ... (loading logic)
loadingRef.current = false;
```

3. Updated the intersection observer logic:

```jsx
if (lastCard.isIntersecting && !loadingRef.current) {
  const nextPage = Math.floor(data.length / CARDS_PER_PAGE) + 1;
  if (!loadedPages.has(nextPage)) {
    loadData(nextPage, true);
  }
}
```

4. Simplified the initial load to fetch only the first page, then preload the second:

```jsx
const initialLoad = async () => {
  await loadData(1, false);
  if (hasMore) await loadData(2, true);
};
```

5. Removed the separate useEffect for preloading, as it's now handled by the intersection observer.

6. Updated the `setPage` call to happen after successful data loading:

```jsx
setPage(pageToLoad);
```

These changes ensure that:
- Each page is only loaded once.
- The loading state is tracked accurately across renders.
- The next page is only loaded when the current page is fully loaded.
- The intersection observer triggers the load for the next unloaded page.

This should prevent multiple calls to the same page and provide a more efficient and smoother infinite scrolling experience.
