 I see. Thank you for clarifying that each page contains 12 cards. In that case, we'll need to adjust the logic to ensure we're always keeping at least one full page ahead. Here's an updated version of the `CardList` component that accounts for 12 cards per page:

```jsx
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { Row, Col, Spin } from 'antd';
import CardItem from './CardItem';

const CARDS_PER_PAGE = 12;

const CardList = () => {
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(false);
  const [preloading, setPreloading] = useState(false);
  const [hasMore, setHasMore] = useState(true);
  const [page, setPage] = useState(1);
  const [loadedPages, setLoadedPages] = useState(new Set());
  const observerRef = useRef(null);
  const lastCardRef = useRef(null);

  const loadData = useCallback(
    async (pageToLoad, isPreload = false) => {
      if (loadedPages.has(pageToLoad) || (isPreload ? preloading : loading)) return;

      if (isPreload) setPreloading(true);
      else setLoading(true);

      try {
        const newData = await fetchData(pageToLoad);
        if (newData.length === 0) {
          setHasMore(false);
        } else {
          setData((prevData) => [...prevData, ...newData]);
          setLoadedPages((prev) => new Set(prev).add(pageToLoad));
        }
      } catch (error) {
        console.error('Error fetching data:', error);
      } finally {
        if (isPreload) setPreloading(false);
        else setLoading(false);
      }
    },
    [loadedPages, loading, preloading]
  );

  useEffect(() => {
    const initialLoad = async () => {
      setLoading(true);
      for (let i = 1; i <= 2; i++) {
        await loadData(i, false);
        setPage(i);
        if (!hasMore) break;
      }
      setLoading(false);
    };

    if (data.length === 0 && !loading && !preloading) {
      initialLoad();
    }
  }, [loadData, data.length, hasMore, loading, preloading]);

  useEffect(() => {
    if (!loading && hasMore) {
      const options = {
        root: null,
        rootMargin: '0px',
        threshold: 0.1,
      };

      observerRef.current = new IntersectionObserver((entries) => {
        const lastCard = entries[0];
        if (lastCard.isIntersecting) {
          setPage((prevPage) => prevPage + 1);
        }
      }, options);

      if (lastCardRef.current) {
        observerRef.current.observe(lastCardRef.current);
      }
    }

    return () => observerRef.current?.disconnect();
  }, [loading, hasMore, data]);

  useEffect(() => {
    const remainingCards = data.length % CARDS_PER_PAGE;
    const shouldLoadNextPage = remainingCards === 0 || remainingCards >= CARDS_PER_PAGE / 2;

    if (shouldLoadNextPage && !preloading && hasMore) {
      loadData(page + 1, true);
    }
  }, [page, loadData, preloading, data.length, hasMore]);

  useEffect(() => {
    if (observerRef.current && lastCardRef.current) {
      observerRef.current.observe(lastCardRef.current);
    }
  }, [data, observerRef, lastCardRef]);

  return (
    <div style={{ padding: '20px' }}>
      <Row gutter={[16, 16]}>
        {data.map((item, index) => (
          <Col
            key={index}
            xs={24}
            sm={12}
            md={8}
            ref={index === data.length - CARDS_PER_PAGE / 2 ? lastCardRef : null}
          >
            <CardItem data={item} />
          </Col>
        ))}
      </Row>
      {loading && data.length === 0 && (
        <div style={{ textAlign: 'center', padding: '20px' }}>
          <Spin />
        </div>
      )}
      {!hasMore && !loading && (
        <div style={{ textAlign: 'center', padding: '20px', color: 'grey' }}>
          No more data to load
        </div>
      )}
      {preloading && (
        <div style={{ textAlign: 'center', padding: '20px', color: 'blue' }}>
          Loading more data...
        </div>
      )}
    </div>
  );
};

// ... rest of the code remains the same

export default CardList;
```

Key changes in this updated version:

1. Added a constant `CARDS_PER_PAGE = 12` to make the code more flexible and easier to maintain.

2. Modified the initial load to fetch only 2 pages instead of 3, as each page now contains 12 cards.

3. Updated the preloading logic in the useEffect hook:

```jsx
useEffect(() => {
  const remainingCards = data.length % CARDS_PER_PAGE;
  const shouldLoadNextPage = remainingCards === 0 || remainingCards >= CARDS_PER_PAGE / 2;

  if (shouldLoadNextPage && !preloading && hasMore) {
    loadData(page + 1, true);
  }
}, [page, loadData, preloading, data.length, hasMore]);
```

This new logic ensures that:
- If we've just completed a full page (remainingCards === 0), we load the next page.
- If we're halfway through the current page (remainingCards >= CARDS_PER_PAGE / 2), we start loading the next page.

4. Updated the ref assignment for the last observed card:

```jsx
ref={index === data.length - CARDS_PER_PAGE / 2 ? lastCardRef : null}
```

This assigns the ref to the card that's halfway through the last loaded page, triggering the next load earlier.

These changes ensure that the component always stays at least half a page ahead in loading data, providing a smooth infinite scrolling experience with 12 cards per page.
